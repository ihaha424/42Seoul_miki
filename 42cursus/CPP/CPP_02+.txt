Orthodox Canonical Form
	• Default constructor
	• Copy constructor
	• Copy assignment operator
	• Destructor

고정 소수점
	고정소수점 (Fixed Point) 표현 방식고정소수점 표현 방식이라는 것은 쉽게 말해 위에서 설명한 방법대로 10진수를 2진수로 바꿨으면, 그걸 그대로 박아넣는 방식이다.예를 들면 7.625라는 실수가 있다고 치자. 2진수로 변환하면 111.101이 될 것이다. 이걸 이렇게 저장한다.
	num (binary): 0000 0101
	num << 8 (binary): 0000 0101 0000 0000
	// 2147483645
	// 01111111 11111111 11111111 11111101
	// -768
	// 11111111 11111111 11111101 00000000
	// -3
	// 11111111 11111111 11111111 11111101

	// 2139095037
	// 01111111 01111111 11111111 11111101
	// 2147482880
	// 01111111 11111111 11111101 00000000
	// 8388605
	// 00000000 01111111 11111111 11111101

	// -8388609
	// 11111111 01111111 11111111 11111111
	// 2147483392
	// 01111111 11111111 11111111 00000000
	// 8388607
	// 00000000 01111111 11111111 11111111
	실험결과 <<는 그냥 0으로 채워지고 >>은 부호에따라 1,0으로 채워진다.
비트연산
	새로운 비트의 채워짐:
		오른쪽 시프트 연산에서는 빈 자리를 어떻게 채울지에 대한 규칙이 있습니다.
		대부분의 컴퓨터 시스템에서는 새로운 비트를 부호 비트와 동일한 값으로 채웁니다. 이는 부호를 유지하면서 쉬프트 연산을 수행하는데 도움이 됩니다.
		따라서 음수인 경우(부호 비트가 1), 새로운 비트는 1로 채워지고, 양수인 경우(부호 비트가 0), 새로운 비트는 0으로 채워집니다.
ex00
	복사생산자
		Fixed(const Fixed& obj);
		ex>
			Fixed a;
			Fixed b = a;
	복사대입연산자
		Fixed& operator = (const Fixed& obj);
		ex>
			Fixed a;
			Fixed b;
			b = a;
	자체할당
		예기치 못한 변수가 발생할 수 있음으로 대입연산자같은 경우 방지해 주는 것이 좋다.
	rhs, lhs
		right-hand side
		left-hand side
		로 일반적으로 이항연산자에서 왼쪽, 오른쪽을 표기하는데 사용된다.
ex01
	출력스트림에연산자오버로딩
		friend std::ostream& operator << (std::ostream& out, const Fixed& rhs);
			두번째 매개 변수에 const 써주면 안된다.
			변수에 입력을 해준다는건 변수의 값을 바꾼다는 의미인데 const면 입력을 할 수가 없음!
			friend는 비멤버 함수를 해당 클래스의 멤버 함수로 선언하는 데 사용
			즉, friend로 선언된 함수는 클래스의 프렌드 함수가 되어 해당 클래스의 private 및 protected 멤버에 접근할 수 있습니다.
ex02
	전위,후위 연산자
		전위:
			Fixed& operator ++ (void);
		후위:
			Fixed operator ++ (int);
		※ 후위 연산자를 오버로딩 하기 위해서 매개 변수로 int를 넘기는데 이때 int는 특별한 의미를 가지는 것이 아니라 전위/후위 연산자의 구분을 위한 것이다.

		차이는 반환할 때 발생한다
		전위 연산자는 증감된 값을 참조형으로 반환하지만 후위 연산자는 값은 증가시키지만 증감 전의 값을 임시 객체로 만들어서 반환한다. 그래서 증감된 값은 다음 행에서야 사용할 수 있는 것이다.
	속도 차이
		전위 연산자 vs 후위 연산자의 속도 차이
		전위 연산자는 값의 참조형을 반환 하지만 후위 연산자는 임시 객체를 만드는 과정이 추가된다. 일반적인 자료형의 경우 큰 차이가 없을 수 있지만 사용자 정의 자료형의 경우 클래스의 멤버 변수들을 전부 복사해야 하므로 그만큼 느려지게 된다. 이런 경우 전위 연산자를 사용하면 속도 면에서 이득을 볼 수 있다.


